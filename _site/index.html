<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>BeyondThunderdo.me</title>
    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
    <link rel="shortcut icon" href="images/favicon.ico">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
    <div id="header">
        <nav>
            <li class="fork"><a href="/">BeyondThunderdo.me</a></li>
            <li class="fork"><a href="/archive/">Archive</a></li>
        </nav>
    </div><!-- end header -->



    <div class="wrapper">

                <section>

    <div id="title">
        <h1>BeyondThunderdo.me</h1>
        <p>I make things. Sometimes I post them here.</p>
    </div>

    <div style="display:table, width: 50%">
    <hr>

        <div class="personalDescription">
            <img src="/images/RobertOnBeach.png" title="Thanks, Emma Ross :)">
            <h3>Robert Butler</h3>
            Software Engineer<br>
            <a href="http://twistedoakstudios.com/">Twisted Oak Studios</a><br>
            <a href="https://twitter.com/BoTreats"><img src="/images/twitterIcon.png" class="iconLinkImage"></a>
            <a href="https://github.com/rbrt"><img src="/images/githubIcon.png" class="iconLinkImage"></a>
            <a href="https://ca.linkedin.com/pub/robert-butler/ab/ab9/753"><img src="/images/linkedinIcon.png" class="iconLinkImage"></a>
            <a href="mailto:robbutler902@gmail.com"><img src="/images/mailIcon.png" class="iconLinkImage"></a>
        </div>
    </div>


    
        <div class="post">
            <h2 id="vertex-painting">Vertex Painting</h2>
<h5>February 12 2017</h5>

<p>Last night I started modeling a second car. I picked something less boxy than the
AE86 so that it would force me to spend some time getting the round bits correct.
I still have a long way to go as a 3D artist, but I’m pretty happy with what came
out. The car I decided to model is an NA Mazda Miata:</p>

<p><img src="/images/2017/Feb/MiataModeling.png" /></p>

<p>I learned a few new things this time. One of these was the mirroring tool, to
save me from having to repeat the same actions on either side of the car. Since
cars are almost always symmetrical, they are a great use case for it. However I
learned about this tool at the end of the process, so I’ll use it from the start
on the next car. The other thing I learned about was vertex painting. I knew that
you could give vertices colour information, but I assumed that I would have to stack
multiple vertices on top of one another to get different coloured faces sharing the
same vertex. However, it turns out that Blonder will let you select faces and
then paint them how you like. Perfect!</p>

<p><img src="/images/2017/Feb/VertexPainting.png" /></p>

<p>This let me paint various faces of the model in different shades of black. Then
when I bring the model in to Unity, I use a shader to look at the vertex’s colour
and convert that to a corresponding colour defined on the material. For the last
model, I was using a texture. I like this approach a lot more. I would like to
determine a cool effect for reflections in the game, maybe just a matcap, but for
now I’m just making all windows and glass light blue. Here’s the finished-ish model:</p>

<p><img src="/images/2017/Feb/MiataSpin.gif" /></p>

        </div>

    	<hr>
    
        <div class="post">
            <h2 id="car-selection">Car Selection</h2>
<h5>February 11 2017</h5>

<p>As it stands right now, there is a stub scene for every state in my game’s flow.
At the very least, an empty scene is loaded and a transition occurs, but I’ve started
adding some functionality to those stub scenes as well. Today I spent some time
fleshing out my car select screen:</p>

<p><img src="/images/2017/Feb/CarSelect.gif" /></p>

<p>Unfortunately I only have one car, but it’s still cycling through the list and
should work fine as more cars are added. To rig that scene up, I made more use of
my recording system and added some pause/resume functionality to the playback. I
just recorded the car doing a drift on an isolated stretch of track, found a good
point to pause it at, and made that the point where cars will stop to be displayed.
Pulling back a bit, you can see what cycling through the cars actually looks like:</p>

<p><img src="/images/2017/Feb/CarSelectTop.gif" /></p>

<p>I also started work on a background setup. The way this works is I have a camera
which culls everything that isn’t on my “Background” layer, and my regular camera
can’t see anything on that layer. The background camera is drawn first, and then
the regular gameplay only clears on depth and draws over it. The background camera
also rotates in sync with the gameplay camera. Using this setup, I’ll place a bunch
of things floating in the sky somewhere:</p>

<p><img src="/images/2017/Feb/BackgroundSetup.png" /></p>

<p>Right now it’s just some water I made awhile ago and a giant sun, but it’s easy
enough to add more things and have different contents for different levels. This
is how the setup appears in game:</p>

<p><img src="/images/2017/Feb/Background.gif" /></p>

        </div>

    	<hr>
    
        <div class="post">
            <h2 id="state-management">State Management</h2>
<h5>February 4 2017</h5>

<p>Mountain Drift is now getting to the point where I need to handle transitions between
different game states, and the operations to do so are varied and non-trivial.
I’m also finding that as I develop different parts of the game, it’s good to be
able to start in any of my scenes instead of having to navigate to them through
normal game flow. Unfortunately, that causes issues with instantiation of UI in
different states, and concerns with what has and has not been initialized.</p>

<p>To help with both of these problems, I decided to write a state management backend.
I’ve done this a few times before, mainly for projects at previous jobs, and I
feel like I have a pretty good handle on it at this point. The core of the system
is that there are several defined states, and transitioning between them invokes
a set of functions. This operation tries to be as atomic as it can, so there can
be a guarantee of nothing unexpected occurring during a transition.</p>

<p>Previously, I’ve worked under the idea that a state transition means loading a new
scene. This works well enough, but it leads to some awkward hacks and entangled
code when you don’t necessarily want to load a new scene, or when unloading the
current scene causes problems. The main design flaw that enforced this limitation
was that my state manager was also my loading controller. In this implementation
I’ve decomposed the two into separate classes. Now, a transition can load a scene,
but it isn’t forced to do so.</p>

<p>To facilitate this, I’ve defined several states, and created a StateTransition
struct. The struct defines what states can be transitioned to from the current
state, and also has three functions. <code class="highlighter-rouge">transitionFromAction</code> is what sort of operations
to perform when exiting the state (cleanup, logging, etc.), <code class="highlighter-rouge">transitionToAction</code> is
the operation to perform when entering a state (initialization, music change, etc.),
and <code class="highlighter-rouge">startupAction</code> is what to perform when this state is the first state the game
starts up in.</p>

<p><img src="/images/2017/Feb/FlowStates.png" /></p>

<p>To clarify, <code class="highlighter-rouge">startupAction</code> is mostly for when debugging. For example: if I want
to start immediately in a gameplay scene instead of starting from the intro, this
will instantiate and set the UI to the correct state, initialize all of the scoring
variables, automatically pick a default car, and so on. This seems like an obvious
thing to do now, but in previous implementations, starting from an unconventional
state has necessitated hacks to make various systems work properly.</p>

<p>The state transitions for the game are defined in a Dictionary which maps a given
state to a StateTransition struct.</p>

<p><img src="/images/2017/Feb/StateTransitions.png" /></p>

<p>When a transition is invoked, if the next state is not valid based on the transition’s
next states, the transition will fail. If it is valid, the “from” and “to” functions
will be invoked, and the new state will be set as the active state. Sometimes,
empty functions (<code class="highlighter-rouge">() =&gt; {}</code>) are passed as a transition’s functions. This is done
when I don’t actually need to load a new scene, or when no other operations need to
take place.</p>

        </div>

    	<hr>
    
        <div class="post">
            <h2 id="boostin">Boostin’</h2>
<h5>February 2 2017</h5>

<p>I’ve banged out a few more features over the last week or so, the most significant
of which is the ability to use a boost. Initially, the boost worked MarioKart
style - as you drift, your boost becomes more powerful. When you exit the drift,
the boost kicks in. This seemed to work, but was kind of annoying to me. To confirm
that theory, I got a few  people to play the game at our monthly Halifax Game Collective
meetup. Almost everyone went flying off the track when it kicked it, so I decided
to make it something that is activated by the player instead.</p>

<p>Now, as you drift, a <i>Boost Bar</i> is filled up. When you successfully complete the
drift, the boost is added to your <i>Boost Bar</i>. Once you’ve accumulated boost,
you can activate it at any time. This lets you try to correct a bad drift off
track, gain speed before a drift, keep momentum through a drift, etc. In terms of
implementation, boosting just applies a greater amount of force to the car, and
increases the velocity that the car’s rigidbody is capped at. I experimented for
awhile until finding a value that produced a noticeable amount of speed without
making the car uncontrollable, but I exaggerate it with some camera shake and FOV
changes anyway.</p>

<p><img src="/images/2017/Feb/Boostin.gif" /></p>

<p>I also added a lap timer, and some more drifting indications. You’ll now see the
current drift’s possible score, current distance, and possible boost. Colliding
into an object, or flying off the track will cancel everything you’ve accumulated
so far. I’ve fixed a few small bugs. Getting some play testing at the meetup was
a really positive experience. Seeing people have fun and want to keep trying was
really motivating, even if no one was able to finish the track…</p>

        </div>

    	<hr>
    
        <div class="post">
            <h2 id="track-tool">Track Tool</h2>
<h5>January 25 2017</h5>

<p>I made the track I’ve been using for testing by creating a path in Blonder, creating
an extrusion shape, extruding that along the path, and converting it to a mesh. I
thought that I might create some standard objects in Blonder to help try and establish
a pipeline for creating track segments, but I thought it would be more ideal to have
something that I could utilize right in Unity. By making a few tools for the engine,
I’d be able to edit tracks directly in scenes, have access to the spline and point
orientation data for any purpose, and I’d get to write editor scripts.</p>

<p>Fortunately, I saw a talk at Unite Boston two years ago that covered a large
chunk of this work: <a href="https://www.youtube.com/watch?v=o9RK6O2kOKo">A coder’s guide to spline-based procedural geometry.</a>
It doesn’t provide complete code, and some of the provided code needed some massaging
to function properly, but it helped me get the generation of a mesh based on an
extrusion shape and a spline working quickly. At first though, I ran into some issues
with the generated MeshCollider:</p>

<p><img src="/images/2017/Jan/ShapedTrackError.gif" /></p>

<p>After getting that in order, I started converting it and wrapping it with an editor
tool. So far, I can add/remove spline segments and edit their points and tangents. Doing
this updates the mesh and its MeshCollider in real time so that I can see how the changes
look, and also immediately test them with my car.</p>

<p><img src="/images/2017/Jan/TrackTool.gif" /></p>

<p>I can bake the segments down into a single track, or bake them into individual segments.
I’m not sure how much performance is going to be a concern at this point, but even
if large tracks work out nicely with respect to framerate, the idea of having reusable
smaller segments appeals to me too. The baked tracks are ScriptableObjects with their
curve information exposed. Presently I’m just using this to place road signs along
the edge of turns, but I’d like to use that information to blend mountains and other
scenery into the edge of the track.</p>

<p>More immediate next steps for this tool are to add better UV scaling which accounts
for curves, which the talk linked above goes into. The tool also doesn’t handle
rotation of points and tangents on the segment curves which will be important.
Another near-future feature will be a visualization for how intense curves are,
to help me eyeball difficult segments without needing to drive the track.</p>

<p><img src="/images/2017/Jan/CarOnGeneratedTrack.gif" /></p>

        </div>

    	<hr>
    

    <a href="/archive/"><h1 style="text-align:center; margin-top:5%;">Older Posts</h1></a>



</section>


    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-53820142-1', 'auto');
        ga('send', 'pageview');
    </script>
  </body>
</html>
